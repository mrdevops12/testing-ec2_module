terraform {
  required_version = ">= 1.3.2"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 5.75, < 6.0.0"
    }
    helm = {
      source  = "hashicorp/helm"
      version = ">= 2.7"
    }
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = ">= 2.20"
    }
    kubectl = {
      source  = "alekc/kubectl"
      version = ">= 2.0"
    }
  }
}

# Build ingress annotations with optional TLS & external-dns
locals {
  grafana_ingress_annotations = merge(
    {
      "kubernetes.io/ingress.class"           = "alb"
      "alb.ingress.kubernetes.io/scheme"      = var.grafana_alb_scheme
      "alb.ingress.kubernetes.io/target-type" = "ip"
    },
    var.grafana_certificate_arn != "" ? {
      "alb.ingress.kubernetes.io/certificate-arn" = var.grafana_certificate_arn
    } : {},
    var.grafana_external_dns_hostname != "" ? {
      "external-dns.alpha.kubernetes.io/hostname" = var.grafana_external_dns_hostname
    } : {}
  )
}

# We assume the 'monitoring' namespace already exists (created by the Prometheus module).
# Keep create_namespace=false here.
resource "helm_release" "grafana" {
  name             = "grafana"
  namespace        = var.namespace
  repository       = var.grafana_chart_repo        # e.g. oci://123456789012.dkr.ecr.us-east-1.amazonaws.com
  chart            = "actions/grafana/grafana"
  version          = var.grafana_chart_version
  create_namespace = false
  atomic           = true

  values = [
    yamlencode({
      # Optional: set admin password now, or leave blank to use the chart default / secret
      adminPassword = var.grafana_admin_password != "" ? var.grafana_admin_password : null

      # IMPORTANT: quote "grafana.ini" because it contains a dot
      "grafana.ini" = {
        server = {
          domain   = var.grafana_host
          root_url = "https://${var.grafana_host}"
        }
      }

      # Use ALB Ingress; keep Service as ClusterIP
      service = {
        type = "ClusterIP"
      }

      ingress = {
        enabled          = true
        ingressClassName = "alb"
        annotations      = local.grafana_ingress_annotations
        hosts            = [var.grafana_host]
        path             = "/"
        pathType         = "Prefix"
      }
    })
  ]
}






variable "namespace" {
  description = "Namespace to deploy Grafana"
  type        = string
}

variable "grafana_chart_repo" {
  description = "OCI repo that hosts the Grafana chart (e.g. oci://<acct>.dkr.ecr.<region>.amazonaws.com)"
  type        = string
}

variable "grafana_chart_version" {
  description = "Grafana Helm chart version (tag), e.g. 8.6.2"
  type        = string
}

variable "grafana_host" {
  description = "DNS host users will hit (e.g. grafana.devops-tools.prd.aws.qdx.com)"
  type        = string
}

variable "grafana_alb_scheme" {
  description = "ALB scheme (internal | internet-facing)"
  type        = string
  default     = "internal"
}

variable "grafana_certificate_arn" {
  description = "ACM cert ARN for TLS (optional). Leave empty for HTTP."
  type        = string
  default     = ""
}

variable "grafana_external_dns_hostname" {
  description = "external-dns hostname to register (optional). Leave empty to skip."
  type        = string
  default     = ""
}

variable "grafana_admin_password" {
  description = "Optional admin password (leave empty to use chart default/secret)."
  type        = string
  default     = ""
}



module "grafana" {
  source = "./modules/grafana"

  namespace             = "monitoring"  # same as Prometheus
  grafana_chart_repo    = var.grafana_chart_repo
  grafana_chart_version = var.grafana_chart_version
  grafana_host          = var.grafana_host

  # Optional (showing defaults)
  grafana_alb_scheme            = "internal"
  grafana_certificate_arn       = ""
  grafana_external_dns_hostname = ""
  grafana_admin_password        = var.grafana_admin_password
}


grafana_chart_repo     = "oci://817786531545.dkr.ecr.us-east-1.amazonaws.com"
grafana_chart_version  = "8.6.2"
grafana_host           = "grafana.devops-tools.prd.aws.qdx.com"

# Optional (can add later)
# grafana_admin_password        = "SuperSecret!"
# grafana_certificate_arn       = "arn:aws:acm:us-east-1:...:certificate/..."
# grafana_external_dns_hostname = "grafana.devops-tools.prd.aws.qdx.com"
# grafana_alb_scheme            = "internal" # or "internet-facing"




resource "kubectl_manifest" "monitoring_namespace" {
  yaml_body = <<YAML
apiVersion: v1
kind: Namespace
metadata:
  name: ${var.namespace}
  labels:
    kubernetes.io/metadata.name: ${var.namespace}
    pod-security.kubernetes.io/enforce: privileged
    pod-security.kubernetes.io/enforce-version: v1.30
    pod-security.kubernetes.io/audit: privileged
    pod-security.kubernetes.io/audit-version: v1.30
    pod-security.kubernetes.io/warn: privileged
    pod-security.kubernetes.io/warn-version: v1.30
YAML
}












# add to annotations used by the grafana ingress
"alb.ingress.kubernetes.io/healthcheck-path"   = "/api/health"
"alb.ingress.kubernetes.io/success-codes"      = "200-399"
"alb.ingress.kubernetes.io/healthcheck-port"   = "traffic-port"
"alb.ingress.kubernetes.io/healthcheck-interval-seconds" = "15"
"alb.ingress.kubernetes.io/healthcheck-timeout-seconds"  = "5"
"alb.ingress.kubernetes.io/healthy-threshold-count"      = "2"
"alb.ingress.kubernetes.io/unhealthy-threshold-count"    = "2"



# Namespace you used (looks like "monitoring")
NS=monitoring

# Get the admin user and password from the secret created by the Grafana chart
kubectl -n $NS get secret grafana -o jsonpath='{.data.admin-user}' | base64 -d; echo
kubectl -n $NS get secret grafana -o jsonpath='{.data.admin-password}' | base64 -d; echo


